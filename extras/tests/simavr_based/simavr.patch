diff --git a/simavr/cores/sim_mega1280.c b/simavr/cores/sim_mega1280.c
index 316bfd6..448cfd9 100644
--- a/simavr/cores/sim_mega1280.c
+++ b/simavr/cores/sim_mega1280.c
@@ -85,23 +85,35 @@ const struct mcu_t {
 		AVR_EXTINT_MEGA_DECLARE(7, 'E', PE7, B),
 	},
 	AVR_IOPORT_DECLARE(a, 'A', A),
-	.portb = {
-		.name = 'B', .r_port = PORTB, .r_ddr = DDRB, .r_pin = PINB,
+	AVR_IOPORT_DECLARE_PC(b, 'B', B, 0),      // PB0-7 have PCINT0-7
+	AVR_IOPORT_DECLARE(c, 'C', C),
+	AVR_IOPORT_DECLARE(d, 'D', D),
+	.porte = {
+		.name = 'E', .r_port = PORTE, .r_ddr = DDRE, .r_pin = PINE,
 		.pcint = {
-			.enable = AVR_IO_REGBIT(PCICR, PCIE0),
-			.raised = AVR_IO_REGBIT(PCIFR, PCIF0),
-			.vector = PCINT0_vect,
+			 .enable = AVR_IO_REGBIT(PCICR, PCIE1),
+			 .raised = AVR_IO_REGBIT(PCIFR, PCIF1),
+			 .vector = PCINT1_vect,
 		},
-		.r_pcint = PCMSK0,
+		.r_pcint = PCMSK1,
+		.mask = 1,                        // PE0 has PCINT8
+		.shift = 0
 	},
-	AVR_IOPORT_DECLARE(c, 'C', C),
-	AVR_IOPORT_DECLARE(d, 'D', D),
-	AVR_IOPORT_DECLARE(e, 'E', E),
 	AVR_IOPORT_DECLARE(f, 'F', F),
 	AVR_IOPORT_DECLARE(g, 'G', G),
 	AVR_IOPORT_DECLARE(h, 'H', H),
-	AVR_IOPORT_DECLARE(j, 'J', J),
-	AVR_IOPORT_DECLARE(k, 'K', K),
+	.portj = {
+		.name = 'J', .r_port = PORTJ, .r_ddr = DDRJ, .r_pin = PINJ,
+		.pcint = {
+			 .enable = AVR_IO_REGBIT(PCICR, PCIE1),
+			 .raised = AVR_IO_REGBIT(PCIFR, PCIF1),
+			 .vector = PCINT1_vect,
+		},
+		.r_pcint = PCMSK1,
+		.mask = 0b11111110,               // PJ0-6 have PCINT9-15
+		.shift = -1
+	},
+	AVR_IOPORT_DECLARE_PC(k, 'K', K, 2),      // PK0-7 have PCINT16-23
 	AVR_IOPORT_DECLARE(l, 'L', L),
 
 	AVR_UARTX_DECLARE(0, PRR0, PRUSART0),
@@ -368,7 +380,7 @@ const struct mcu_t {
 					.vector = TIMER2_COMPA_vect,
 				},
 			},
-            // TIMER2_COMPB is only appeared in 1280
+		// TIMER2_COMPB is only appeared in 1280
 			//[AVR_TIMER_COMPB] = {
 			//	.r_ocr = OCR2B,
 			//	.com = AVR_IO_REGBITS(TCCR2A, COM2B0, 0x3),
@@ -651,8 +663,8 @@ static avr_t * make()
 }
 
 avr_kind_t mega1280 = {
-        .names = { "atmega1280" },
-        .make = make
+	.names = { "atmega1280" },
+	.make = make
 };
 
 void m1280_init(struct avr_t * avr)
diff --git a/simavr/cores/sim_mega1281.c b/simavr/cores/sim_mega1281.c
index 222743c..1d121e5 100644
--- a/simavr/cores/sim_mega1281.c
+++ b/simavr/cores/sim_mega1281.c
@@ -81,18 +81,20 @@ const struct mcu_t {
 		AVR_EXTINT_MEGA_DECLARE(7, 'E', PE7, B),
 	},
 	AVR_IOPORT_DECLARE(a, 'A', A),
-	.portb = {
-		.name = 'B', .r_port = PORTB, .r_ddr = DDRB, .r_pin = PINB,
+	AVR_IOPORT_DECLARE_PC(b, 'B', B, 0),      // PB0-7 have PCINT0-7
+	AVR_IOPORT_DECLARE(c, 'C', C),
+	AVR_IOPORT_DECLARE(d, 'D', D),
+	.porte = {
+		.name = 'E', .r_port = PORTE, .r_ddr = DDRE, .r_pin = PINE,
 		.pcint = {
-			.enable = AVR_IO_REGBIT(PCICR, PCIE0),
-			.raised = AVR_IO_REGBIT(PCIFR, PCIF0),
-			.vector = PCINT0_vect,
+			 .enable = AVR_IO_REGBIT(PCICR, PCIE1),
+			 .raised = AVR_IO_REGBIT(PCIFR, PCIF1),
+			 .vector = PCINT1_vect,
 		},
-		.r_pcint = PCMSK0,
+		.r_pcint = PCMSK1,
+                .mask = 1,                        // PE0 has PCINT8
+                .shift = 0
 	},
-	AVR_IOPORT_DECLARE(c, 'C', C),
-	AVR_IOPORT_DECLARE(d, 'D', D),
-	AVR_IOPORT_DECLARE(e, 'E', E),
 	AVR_IOPORT_DECLARE(f, 'F', F),
 	AVR_IOPORT_DECLARE(g, 'G', G),
 
diff --git a/simavr/cores/sim_mega2560.c b/simavr/cores/sim_mega2560.c
index a967b78..ecd1949 100644
--- a/simavr/cores/sim_mega2560.c
+++ b/simavr/cores/sim_mega2560.c
@@ -29,8 +29,8 @@ static avr_t * make()
 }
 
 avr_kind_t mega2560 = {
-		 .names = { "atmega2560" },
-		 .make = make
+		.names = { "atmega2560", "atmega2561" },
+		.make = make
 };
 
 void m2560_init(struct avr_t * avr)
@@ -57,6 +57,7 @@ void m2560_init(struct avr_t * avr)
 	avr_uart_init(avr, &mcu->uart1);
 	avr_uart_init(avr, &mcu->uart2);
 	avr_uart_init(avr, &mcu->uart3);
+        avr_acomp_init(avr, &mcu->acomp);
 	avr_adc_init(avr, &mcu->adc);
 	avr_timer_init(avr, &mcu->timer0);
 	avr_timer_init(avr, &mcu->timer1);
diff --git a/simavr/cores/sim_mega2560.h b/simavr/cores/sim_mega2560.h
index f8a41a1..8fb48e8 100644
--- a/simavr/cores/sim_mega2560.h
+++ b/simavr/cores/sim_mega2560.h
@@ -87,18 +87,20 @@ const struct mcu_t {
 		AVR_EXTINT_MEGA_DECLARE(7, 'E', PE7, B),
 	},
 	AVR_IOPORT_DECLARE(a, 'A', A),
-	.portb = {
-		.name = 'B', .r_port = PORTB, .r_ddr = DDRB, .r_pin = PINB,
+	AVR_IOPORT_DECLARE_PC(b, 'B', B, 0),      // PB0-7 have PCINT0-7
+	AVR_IOPORT_DECLARE(c, 'C', C),
+	AVR_IOPORT_DECLARE(d, 'D', D),
+	.porte = {
+		.name = 'E', .r_port = PORTE, .r_ddr = DDRE, .r_pin = PINE,
 		.pcint = {
-			 .enable = AVR_IO_REGBIT(PCICR, PCIE0),
-			 .raised = AVR_IO_REGBIT(PCIFR, PCIF0),
-			 .vector = PCINT0_vect,
+			 .enable = AVR_IO_REGBIT(PCICR, PCIE1),
+			 .raised = AVR_IO_REGBIT(PCIFR, PCIF1),
+			 .vector = PCINT1_vect,
 		},
-		.r_pcint = PCMSK0,
+		.r_pcint = PCMSK1,
+                .mask = 1,                        // PE0 has PCINT8
+                .shift = 0
 	},
-	AVR_IOPORT_DECLARE(c, 'C', C),
-	AVR_IOPORT_DECLARE(d, 'D', D),
-	AVR_IOPORT_DECLARE(e, 'E', E),
 	AVR_IOPORT_DECLARE(f, 'F', F),
 	AVR_IOPORT_DECLARE(g, 'G', G),
 	AVR_IOPORT_DECLARE(h, 'H', H),
@@ -108,12 +110,12 @@ const struct mcu_t {
 			 .enable = AVR_IO_REGBIT(PCICR, PCIE1),
 			 .raised = AVR_IO_REGBIT(PCIFR, PCIF1),
 			 .vector = PCINT1_vect,
-			 .mask = 0b11111110,
-			 .shift = -1
 		},
 		.r_pcint = PCMSK1,
+                .mask = 0b11111110,               // PJ0-6 have PCINT9-15
+                .shift = -1
 	},
-	AVR_IOPORT_DECLARE(k, 'K', K),
+	AVR_IOPORT_DECLARE_PC(k, 'K', K, 2),      // PK0-7 have PCINT16-23
 	AVR_IOPORT_DECLARE(l, 'L', L),
 
 	AVR_UARTX_DECLARE(0, PRR0, PRUSART0),
diff --git a/simavr/sim/avr_extint.c b/simavr/sim/avr_extint.c
index e8dd9bc..6f85660 100644
--- a/simavr/sim/avr_extint.c
+++ b/simavr/sim/avr_extint.c
@@ -37,9 +37,14 @@ static avr_cycle_count_t avr_extint_poll_level_trig(
 		void * param)
 {
 	avr_extint_poll_context_t *poll = (avr_extint_poll_context_t *)param;
-	avr_extint_t * p = (avr_extint_t *)poll->extint;
+	avr_extint_t * p = poll->extint;
 
-	char port = p->eint[poll->eint_no].port_ioctl & 0xFF;
+	/* Check for change of interrupt mode. */
+
+	if (avr_regbit_get_array(avr, p->eint[poll->eint_no].isc, 2))
+		goto terminate_poll;
+
+	uint8_t port = p->eint[poll->eint_no].port_ioctl & 0xFF;
 	avr_ioport_state_t iostate;
 	if (avr_ioctl(avr, AVR_IOCTL_IOPORT_GETSTATE( port ), &iostate) < 0)
 		goto terminate_poll;
@@ -176,9 +181,9 @@ static void avr_extint_reset(avr_io_t * port)
 	avr_extint_t * p = (avr_extint_t *)port;
 
 	for (int i = 0; i < EXTINT_COUNT; i++) {
-		avr_irq_register_notify(p->io.irq + i, avr_extint_irq_notify, p);
-
 		if (p->eint[i].port_ioctl) {
+			avr_irq_register_notify(p->io.irq + i, avr_extint_irq_notify, p);
+
 			if (p->eint[i].isc[1].reg) // level triggering available
 				p->eint[i].strict_lvl_trig = 1; // turn on repetitive level triggering by default
 			avr_irq_t * irq = avr_io_getirq(p->io.avr,
@@ -211,10 +216,13 @@ void avr_extint_init(avr_t * avr, avr_extint_t * p)
 	p->io = _io;
 
 	avr_register_io(avr, &p->io);
-	for (int i = 0; i < EXTINT_COUNT; i++)
+	for (int i = 0; i < EXTINT_COUNT; i++) {
+		if (!p->eint[i].port_ioctl)
+			break;
 		avr_register_vector(avr, &p->eint[i].vector);
-
+	}
 	// allocate this module's IRQ
+
 	avr_io_setirqs(&p->io, AVR_IOCTL_EXTINT_GETIRQ(), EXTINT_COUNT, NULL);
 }
 
diff --git a/simavr/sim/avr_ioport.c b/simavr/sim/avr_ioport.c
index 64adbc4..ca43896 100644
--- a/simavr/sim/avr_ioport.c
+++ b/simavr/sim/avr_ioport.c
@@ -24,6 +24,21 @@
 
 #define D(_w)
 
+static void
+avr_ioport_flag_write(
+		struct avr_t * avr,
+		avr_io_addr_t addr,
+		uint8_t v,
+		void * param)
+{
+	avr_ioport_t * p = (avr_ioport_t *)param;
+
+	// Clear interrupt if 1 is written to flag.
+
+	if (avr_regbit_from_value(avr, p->pcint.raised, v))
+		avr_clear_interrupt(avr, &p->pcint);
+}
+
 static uint8_t
 avr_ioport_read(
 		struct avr_t * avr,
@@ -34,11 +49,11 @@ avr_ioport_read(
 	uint8_t ddr = avr->data[p->r_ddr];
 	uint8_t v = (avr->data[p->r_pin] & ~ddr) | (avr->data[p->r_port] & ddr);
 	avr->data[addr] = v;
-	// made to trigger potential watchpoints
-	v = avr_core_watch_read(avr, addr);
 	avr_raise_irq(p->io.irq + IOPORT_IRQ_REG_PIN, v);
 	D(if (avr->data[addr] != v) printf("** PIN%c(%02x) = %02x\r\n", p->name, addr, v);)
 
+	// made to trigger potential watchpoints
+	v = avr_core_watch_read(avr, addr);
 	return v;
 }
 
@@ -122,7 +137,6 @@ avr_ioport_ddr_write(
 	D(if (avr->data[addr] != v) printf("** DDR%c(%02x) = %02x\r\n", p->name, addr, v);)
 	avr_raise_irq(p->io.irq + IOPORT_IRQ_DIRECTION_ALL, v);
 	avr_core_watch_write(avr, addr, v);
-
 	avr_ioport_update_irqs(p);
 }
 
@@ -143,19 +157,47 @@ avr_ioport_irq_notify(
 	int output = value & AVR_IOPORT_OUTPUT;
 	value &= 0xff;
 	uint8_t mask = 1 << irq->irq;
-		// set the real PIN bit. ddr doesn't matter here as it's masked when read.
-	avr->data[p->r_pin] &= ~mask;
-	if (value)
-		avr->data[p->r_pin] |= mask;
+	uint8_t ddr = avr->data[p->r_ddr];
 
-	if (output)	// if the IRQ was marked as Output, also do the IO write
-		avr_ioport_write(avr, p->r_port, (avr->data[p->r_port] & ~mask) | (value ? mask : 0), p);
+	if (output) {
+		if ((mask & ddr) == 0)
+			return;	   // TODO: stop further processing of IRQ.
+
+		// If the IRQ was marked as Output, also do the IO write.
+
+		avr_ioport_write(avr,
+				 p->r_port,
+				 (avr->data[p->r_port] & ~mask) |
+				     (value ? mask : 0),
+				 p);
+	} else {
+		// Set the real PIN bit. Ignore DDR as it's masked when read.
+
+		avr->data[p->r_pin] &= ~mask;
+		if (value)
+			avr->data[p->r_pin] |= mask;
+
+		/* BUG: If DDR bit is set here, there should be no
+		 * interrupt.  But a spurious IRQ call by the user
+		 * is indistinguishable from an internal one
+		 * caused by writing the output port register and
+		 * that should cause an interrupt. Doh!
+		 */
+	}
 
 	if (p->r_pcint) {
+		// Ignore lingering copy of AVR_IOPORT_OUTPUT, or
+		// differing non-zero values.
+
+		if (!value == !(irq->value & 0xff))
+			return;
+
 		// if the pcint bit is on, try to raise it
+
 		int raisedata = avr->data[p->r_pcint];
-		uint8_t uiRegMask = p->pcint.mask;
-		int8_t iShift = p->pcint.shift;
+		uint8_t uiRegMask = p->mask;
+		int8_t iShift = p->shift;
+
 		if (uiRegMask) // If mask is 0, do nothing (backwards compat)
 			raisedata &= uiRegMask; // Mask off
 
@@ -252,7 +294,7 @@ static const char * irq_names[IOPORT_IRQ_COUNT] = {
 	[IOPORT_IRQ_PIN5] = "=pin5",
 	[IOPORT_IRQ_PIN6] = "=pin6",
 	[IOPORT_IRQ_PIN7] = "=pin7",
-	[IOPORT_IRQ_PIN_ALL] = "8=all",
+	[IOPORT_IRQ_PIN_ALL] = "8>all",
 	[IOPORT_IRQ_DIRECTION_ALL] = "8>ddr",
 	[IOPORT_IRQ_REG_PORT] = "8>port",
 	[IOPORT_IRQ_REG_PIN] = "8>pin",
@@ -282,11 +324,17 @@ void avr_ioport_init(avr_t * avr, avr_ioport_t * p)
 	// allocate this module's IRQ
 	avr_io_setirqs(&p->io, AVR_IOCTL_IOPORT_GETIRQ(p->name), IOPORT_IRQ_COUNT, NULL);
 
-	for (int i = 0; i < IOPORT_IRQ_COUNT; i++)
+	for (int i = 0; i < IOPORT_IRQ_REG_PIN; i++) {
 		p->io.irq[i].flags |= IRQ_FLAG_FILTERED;
-
+                if (i < IOPORT_IRQ_PIN_ALL)
+                    p->io.irq[i].flags &= ~IRQ_FLAG_INIT;
+	}
 	avr_register_io_write(avr, p->r_port, avr_ioport_write, p);
 	avr_register_io_read(avr, p->r_pin, avr_ioport_read, p);
 	avr_register_io_write(avr, p->r_pin, avr_ioport_pin_write, p);
 	avr_register_io_write(avr, p->r_ddr, avr_ioport_ddr_write, p);
+	if (p->pcint.raised.reg) {
+		avr_register_io_write(avr, p->pcint.raised.reg,
+				      avr_ioport_flag_write, p);
+	}
 }
diff --git a/simavr/sim/avr_ioport.h b/simavr/sim/avr_ioport.h
index 5734df8..024b695 100644
--- a/simavr/sim/avr_ioport.h
+++ b/simavr/sim/avr_ioport.h
@@ -104,9 +104,15 @@ typedef struct avr_ioport_t {
 	avr_io_addr_t r_pin;
 
 	avr_int_vector_t pcint;	// PCINT vector
-	avr_io_addr_t r_pcint;		// pcint 8 pins mask
+	avr_io_addr_t r_pcint;	// pcint 8 pins mask
 
-	// this represent the default IRQ value when
+	// Mask and shift for PCINTs.  This is needed for chips like the 2560
+	// where PCINT do not align with IRQs.
+
+	uint8_t 	mask;
+	int8_t 		shift;
+
+	// This represent the default IRQ value when
 	// the port is set as input.
 	// If the mask is not set, no output value is sent
 	// on the output IRQ. If the mask is set, the specified
@@ -123,6 +129,18 @@ void avr_ioport_init(avr_t * avr, avr_ioport_t * port);
 		.name = _cname, .r_port = PORT ## _uname, .r_ddr = DDR ## _uname, .r_pin = PIN ## _uname, \
 	}
 
+#define AVR_IOPORT_DECLARE_PC(_lname, _cname, _uname, _pcnum)	\
+	.port ## _lname = { \
+		.name = _cname, .r_port = PORT ## _uname, \
+		.r_ddr = DDR ## _uname, .r_pin = PIN ## _uname, \
+		.pcint = { \
+			 .enable = AVR_IO_REGBIT(PCICR, PCIE ## _pcnum), \
+			 .raised = AVR_IO_REGBIT(PCIFR, PCIF ## _pcnum), \
+			 .vector = PCINT ## _pcnum ## _vect, \
+		}, \
+		.r_pcint = PCMSK ## _pcnum, \
+	}
+
 #ifdef __cplusplus
 };
 #endif
